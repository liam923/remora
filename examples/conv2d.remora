;; ---------------------------- UTILITIES ---------------------------------------------
(define (indices-of/2{| d1 d2}): [int d1 d2 2]
((fn ([id [int]]) [(/ id (reify-dimension d1)) (% id (reify-dimension d1))]) iota{| [d1 d2]}))
  ; (let [d1-val (reify-dimension d1)]
  ;   ((fn ([id [int]]) [(/ id d1-val) (% id d1-val)]) iota{| [d1 d2]})))

(define (subarray/2{t | in1 in2 out1 out2} [arr [t in1 in2]] [offset [int 2]])
  (index{t | [in1 in2] [] 2} arr (+ (indices-of/2{| out1 out2}) 
                                    (replicate{int | [out1 out2] [2]} offset))))

(define (flatten/4{t | in1 in2 in3 in4 out1 out2} [arr [t in1 in2 in3 in4]]) : [t out1 out2]
  (reshape [out1 out2] arr))
  ;(reshape [out1 out2] (transpose/4{float | in1 in2 in3 in4 in1 in3 in2 in4 } [0 2 1 3] arr)))

;; ---------------------------- CONVOLUTION ---------------------------------------------
;;(define (conv1d{| n-1 k-1 o} [data [float (+ n-1 1)]] [kernel [float (+ k-1 1)]]) : [float o]
;;  (reduce{float | k-1 [] []} +. (*. (replicate{float | [o] [(+ k-1 1)]} kernel) (subvector{float | (+ n-1 1) (+ k-1 1) []} data iota{| [o]}))))
;;(define (conv2d{| n-1 k-1 pad stride o} [data [float (+ n-1 1) (+ n-1 1)]]
;;                             [kernel [float (+ k-1 1) (+ k-1 1)]])
;;  (subarray/fill data (- indices-of/2{| [o o]} (reify-dimension pad)) [(reify-dimension (+ k-1 1)) (reify-dimension (+ k-1 1))] 0))
;;  (reduce{float | k-1 [] []} +. (reduce{float | k-1 [] []} +. (*. (replicate{float | [(+ out-1 1) (+ in-1 1)] [(+ in-1 1)]} input) weights)))

;; (define (conv-2d{| n-1 k-1 o stride pad} [data [float (+ n-1 1) (+ n-1 1)]]
;;                               [weights [float (+ k-1 1) (+ k-1 1)]]
;;                               [bias [float]]) : [float o o]
;;   (let [windows (subarray/2{float | (+ 1 n-1) (+ 1 n-1) (+ 1 k-1) (+ 1 k-1)}
;;                            data (* (reify-dimension stride) (indices-of/2{| o o})))]
;;     (let [repl-weights (replicate{float | [o o] [(+ k-1 1) (+ k-1 1)]} weights)]
;;       (+. bias (reduce{float | k-1 [] []} +. (reduce{float | k-1 [] []} +. (*. windows repl-weights)))))))

;; (define (conv-2d-back{| n-1 k-1 o-1 pad stride} [data [float (+ 1 n-1) (+ 1 n-1)]]
;;                                                 [weights [float (+ 1 k-1) (+ 1 k-1)]]
;;                                                 [dout [float (+ 1 o-1) (+ 1 o-1)]])
;;   (define din-masks  (reshape [(+ 1 o-1) (+ 1 o-1) (+ 1 n-1) (+ 1 n-1)]
;;                      (flatten/4{float | }
;;                      ((fn ([idx [int 2]] [dout-val [float]])
;;                         (subarray-fill/2{float | 1 1 stride stride} [dout-val] idx 0.0))
;;                       (indices-of/2{| (+ 1 o-1) (+ 1 o-1) }) dout)
;;                      )))
;;   (define (+.out [a [float (+ 1 n-1) (+ 1 n-1)]] [b [float (+ 1 n-1) (+ 1 n-1)]])
;;     (+. a b))
;;   (define din (*. data (reduce{float | o-1 [] [(+ 1 n-1) (+ 1 n-1)]} +.out (reduce{float | o-1 [] [(+ 1 n-1) (+ 1 n-1)]} +.out din-masks))))
;;   (define dw  (conv-2d{|} data dout 0.0))
;;   (define db  (reduce{float | (+ 1 o-1) [] [] } +. (reduce{float | (+ 1 o-1) [] []} +. dout))))
;; ---------------------------- FULLY CONNECTED ---------------------------------------------
;; (define (fc-2d-fwd{| in-1 out-1} [input [float (+ in-1 1)]]
;;                                  [weights [float (+ out-1 1) (+ in-1 1)]]
;;                                  [bias [float (+ out-1 1)]]) : [float (+ out-1 1)]
;;   (+. bias
;;     (reduce{float | in-1 [] []}
;;       +.
;;       (*. (replicate{float | [(+ out-1 1)] [(+ in-1 1)]} input)
;;           weights))))

;; (define (fc-2d-bwd-dx{| dy-dim-1 input-dim-1 }
;;           [dy [float (+ 1 dy-dim-1)]]
;;           [w  [float (+ 1 dy-dim-1) (+ 1 input-dim-1)]]) : [float (+ 1 input-dim-1)]
;;   (reduce{float | dy-dim-1 [] [(+ 1 input-dim-1)] }
;;     (fn ([a [float (+ 1 input-dim-1)]]
;;          [b [float (+ 1 input-dim-1)]]) : [float (+ 1 input-dim-1)]
;;       (+. a b))
;;     (*. dy w)))

;; (define (fc-2d-bwd-dw{| input-dim dy-dim }
;;           [input [float input-dim]]
;;           [dy [float dy-dim]]) : [float dy-dim input-dim]
;;   (*. (replicate{float | [input-dim] []} dy)
;;       (replicate{float | [dy-dim] [input-dim]} input)))

;; (define (fc-2d-bwd-db{| input-dim-1 } [dy [float (+ 1 input-dim-1)]]) : [float]
;;   (reduce{float | input-dim-1 [] []} +. dy))

;;(conv1d{| 4 2 3} [1.0 2.0 3.0 4.0 5.0] [[0.5 1.0 1.5] [1.0 1.0 1.0]])
;;(fc-2d{| 2 1} [1.0 2.0 3.0] [[1.0 2.0 3.0] [0.1 0.2 0.3]] [0.5 0.3])

;; ---------------------------- [MAX] POOLING ---------------------------------------------
;; this one assumes the AD backprop so we don't need to return indices and such
;;(define (max-pool-2d{| in-1 stride pad k-1 out} [input [float (+ in-1 1) (+ in-1 1)]]): [float out out]
;;  (reduce{float | k-1 [] []} max. (reduce{float | k-1 [] []} max-float (subarray/fill input indices-of/2{| [out out]} [(reify-dimension (+ k-1 1)) (reify-dimension (+ k-1 1))]))))

;; for any pooling layer
;;(define (pool-2d{| in-1 stride pad k-1 out cell-elt-count} [input [float (+ in-1 1) (+ in-1 1)]] [reducer (-> (float float) float)])
;;  (reduce-n{| } reducer (reshape [] (subarray/fill input indices-of/2{| [out out]} [(reify-dimension (+ k-1 1)) (reify-dimension (+ k-1 1))])))

(define (max2. [a [float]] [b [float]]) : [float]
  a)
  ;; (select{float | } (>. a b) a b))

(define (min2. [a [float]] [b [float]])
  b)
  ;; (select{float | } (<. a b) a b))

;; (define (foo{| n-1 pool-size-1} [data [float (+ 1 n-1) (+ 1 n-1)]] [index [int 2]])
;;   (reduce{float | pool-size-1 [] []}
;;     max2.
;;     (reduce{float | pool-size-1 [] []}
;;       max2.
;;       (subarray/2{float | (+ 1 n-1) (+ 1 n-1) (+ 1 pool-size-1) (+ 1 pool-size-1)}
;;         data index))))

;; (define (bar{| pool-size} [win [float pool-size pool-size]] [max-val [float]])
;;   (select{float | } (=. win max-val) 1.0 0.0))

;; (define (max-pool-2d{| n-1 pool-size-1 out} [data [float (+ 1 n-1) (+ n-1 1)]]) ;: [float out out]
;;   (define windows (subarray/2{float | (+ 1 n-1) (+ 1 n-1) (+ 1 pool-size-1) (+ 1 pool-size-1) } data (indices-of/2{| out out})))
;;   ;; (define max-per-pool (reduce{float | pool-size-1 [] []} max2. (reduce{float | pool-size-1 [] []} max2. windows)))
;;   ;; (define max-per-pool (reduce{float | pool-size-1 [] [] } +. windows))
;;   (define pool-size (reify-dimension (+ 1 pool-size-1)))
;;   ; mult cause for pooling, pool-size = stride
;;   (define max-per-pool (foo{| n-1 pool-size-1} data (* pool-size (indices-of/2{| out out}))))
;;   max-per-pool)
  ;; (=. (replicate{float | [(+ 1 pool-size-1) (+ 1 pool-size-1)] []} max-per-pool) windows))
  ;; (define mask ((fn ([win [float (+ 1 pool-size-1) (+ 1 pool-size-1)]] [max-val [float]])
  ;;                  (select{float | } (=. win max-val) 1.0 0.0))
  ;;                windows
  ;;                max-per-pool))
  ;; (define mask (bar{| (+ 1 pool-size-1)} windows max-per-pool))
  ;; mask)
  ;; (bar{| (+ 1 pool-size-1)} windows max-per-pool))

;; (define (max-pool-back{|} [mask [float ... ...]] [dout [float ... ...]]) : [float ... ...]
;;   (define max-count-per-pool (reduce{} + (reduce{} + mask)))
;;   (define weighted-max ((fn ([m [int ... ...]] [count [int]] [dout-val [float]])
;;                           (*. dout-val (/. m (int->float count))))
;;                         mask
;;                         max-count-per-pool
;;                         dout))
;;   (define din (reshape (transpose{float|} [0 2 1 3] weighted-max)))

;; ---------------------------- DROPOUT ---------------------------------------------
;; TODO: how to random
;; ---------------------------- BATCH NORMALIZATION -----------------------------------------
;; (define (mean{| n-1 } [input [float (+ 1 n-1) (+ 1 n-1)]])
;;   (define n-val (reify-dimension (+ 1 n-1)))
;;   (/. (reduce{float | n-1 [] [] } +. (reduce{float | n-1 [] []} +. input))
;;       (int->float (* n-val n-val))))
;; (define (variance{| n-1 } [input [float (+ 1 n-1) (+ 1 n-1)]] [mean [float]])
;;   (define n-val (reify-dimension (+ 1 n-1)))
;;   (let [diff-x (-. input mean)]
;;     (/. (reduce{float | n-1 [] []} +. (reduce{float | n-1 [] []} +. (*. diff-x diff-x)))
;;       (int->float (- (* n-val n-val) 1)))))

;; (define (batch-norm-2d{ | n-1 k}
;;                        [input [float k (+ 1 n-1) (+ 1 n-1)]]
;;                        [rolling-mean [float k]]
;;                        [rolling-var [float k]]
;;                        [bias [float k]]
;;                        [train [bool]]) ; : [float k (+ 1 n-1) (+ 1 n-1)]
;;   (define input-mean (mean{| n-1} input))
;;   (define input-var  (variance{| n-1} input input-mean))
;;   (define new-rolling-mean (+. (*. 0.99 rolling-mean) (*. 0.01 input-mean)))
;;   ;; (define new-rolling-var  (+. (*. 0.99 rolling-var)  (*. 0.01 input-var)))
;;   (define mean-to-use (select{float | } train input-mean rolling-mean))
;;   ;; (define var-to-use  (select{float | } train input-var rolling-var))
;;   (define diff-x (-. input mean-to-use))
;;   ;; (define normalized-input (/. diff-x (sqrt (+. var-to-use 0.000001))))
;;   (/. diff-x (+. 0.00001 input-mean)))
;;   ;; (define output (+. normalized-input bias))
;;   ;; output)

(define (batch-norm-2d-back{| n-1 k}
                            [input [float k (+ 1 n-1) (+ 1 n-1)]]
                            [dout  [float k (+ 1 n-1) (+ 1 n-1)]]
                            [mean  [float k]]
                            [var   [float k]]
                            [rolling-mean [float k]]
                            [rolling-var  [float k]]
                            [train [bool]])
  (define n-val (reify-dimension (+ 1 n-1)))
  (define spatial (int->float (* n-val n-val)))
  (define mean-to-use (+. 0.00001 (select{float | } train mean rolling-mean)))
  (define var-to-use  (+. 0.00001 (select{float | } train var rolling-var)))
  (define db (reduce{float | n-1 [] []} +. (reduce{float | n-1 [] []} +. dout)))
  (define dmean (*. -1.0 (/. db ; we need the sum of dout, so we just reuse db
                             (sqrt var-to-use))))
  (define dvar-wip (reduce{float | n-1 [] [] } +. (reduce{float | n-1 [] []} +. (*. dout (-. input mean-to-use)))))
  (define dvar     (*. dvar-wip (*. -0.5 (expt var-to-use -1.5))))
  (define din      (+. (/. dout (sqrt var-to-use))
                       (+. (/. (*. 2.0 (*. dvar (-. input mean-to-use))) spatial)
                           (/. dmean spatial))))
  din)
;; ---------------------------- DETECTION ---------------------------------------------

;; yolo-box - 5 long vector - [x y w h confidence]
;; TODO: ideally put them into a record

(define (yolo-box-rmse [a-full [float 5]] [b-full [float 5]]) : [float]
  (define a (subvector{float | 5 4 []} a-full 0))
  (define b (subvector{float | 5 4 []} b-full 0))
  (sqrt (reduce{float | 3 [] []} +. (expt (-. a b) 2.0))))

(define (overlap [x1 [float]] [w1 [float]] [x2 [float]] [w2 [float]]) : [float]
  (define l1 (-. x1 (/. w1 2.0)))
  (define l2 (-. x2 (/. w2 2.0)))
  (define left (max2. l1 l2))
  (define r1 (+. x1 (/. w1 2.0)))
  (define r2 (+. x2 (/. w2 2.0)))
  (define right (min2. r1 r2))
  (-. right left))

;; inputs are two yolo boxes,
(define (yolo-box-intersect [a [float 5]] [b [float 5]]) : [float]
  ;; This is a really good test for checking how well compiler optimizes this kind of code
  ;; as it similar to what is used in graphics
  (define w (overlap (index{float | [5] [] 1} a [0]) (index{float | [5] [] 1} a [2])
                     (index{float | [5] [] 1} b [0]) (index{float | [5] [] 1} b [2])))
  (define h (overlap (index{float | [5] [] 1} a [1]) (index{float | [5] [] 1} a [3])
                     (index{float | [5] [] 1} b [1]) (index{float | [5] [] 1} b [3])))
  (define area (*. w h))
  area)
  ;; (select{float |} (<. area 0.0) 0.0 area))

(define (yolo-box-area [a [float 5]])
  (*. (index{float | [5] [] 1} a [2]) (index{float | [5] [] 1} a [3])))

(define (yolo-box-union [a [float 5]] [b [float 5]]) : [float]
  (define intersect (yolo-box-intersect a b))
  (+. (yolo-box-area a)
      (+. (yolo-box-area b)
          (-. 0.0 intersect))))

(define (yolo-box-iou [a [float 5]] [b [float 5]]) : [float]
  (/. (yolo-box-intersect a b)
      (yolo-box-union a b)))

(define (best-yolo-box-delta [pred-box [float 5]]
                             [truth-box [float 5]]
                             [coord-scale [float]]
                             [obj-scale [float]]
                             [sqrt-flag [bool]]
                             [rescore-flag [bool]]) : [float 5]
  (define new-w (*. coord-scale (select{float |} sqrt-flag
                                   (-. (sqrt (index{float | [5] [] 1} truth-box [2])) (index{float | [5] [] 1} pred-box [2]))
                                   (-. (index{float | [5] [] 1} truth-box [2]) (index{float | [5] [] 1} pred-box [2])))))
  (define new-h (*. coord-scale (select{float |} sqrt-flag
                                   (-. (sqrt (index{float | [5] [] 1} truth-box [3])) (index{float | [5] [] 1} pred-box [3]))
                                   (-. (index{float | [5] [] 1} truth-box [3]) (index{float | [5] [] 1} pred-box [3])))))
  (define iou (yolo-box-iou pred-box truth-box))
  (define delta-p (select{float |} rescore-flag
                          (*. obj-scale (-. iou (index{float | [5] [] 1} pred-box [4])))
                          (*. obj-scale (-. 1.0 (index{float | [5] [] 1} pred-box [4])))))
  [(*. coord-scale (-. (index{float | [5] [] 1} truth-box [0]) (index{float | [5] [] 1} pred-box [0])))
   (*. coord-scale (-. (index{float | [5] [] 1} truth-box [1]) (index{float | [5] [] 1} pred-box [1])))
   new-w
   new-h
   delta-p])

(define (other-yolo-box-delta [pred-box [float 5]] [noobj-scale [float]]) : [float 5]
  [0.0
   0.0
   0.0
   0.0
   (*. noobj-scale (-. 0.0 (index{float | [5] [] 1} pred-box [4])))])

(define (merge-box-and-class-delta{| classes-num boxes-num} [boxes [float boxes-num 5]] [class-delta [float classes-num]])
  (append{float | (+ boxes-num boxes-num boxes-num boxes-num boxes-num) classes-num []}
          (reshape [(+ boxes-num boxes-num boxes-num boxes-num boxes-num)] boxes)
          class-delta))

;; Precondition: boxes-arr-size = 5 * boxes-num
;; Precondition: n = boxes-arr-size + classes-1 + 1
(define (detection-2d{| n boxes-arr-size boxes-num-1 classes-1}
                      [input        [float n]]
                      [truth        [float n]]
                      [sqrt-flag    [bool]]
                      [rescore-flag [bool]]
                      [obj-scale    [float]]
                      [noobj-scale  [float]]
                      [coord-scale  [float]]
                      [class-scale  [float]])
  (define box-pred (reshape [(+ 1 boxes-num-1) 5] (subvector{float | n boxes-arr-size []} input 0)))
  (define class-pred (subvector{float | n (+ 1 classes-1) []} input (reify-dimension boxes-arr-size)))
  (define truth-box (subvector{float | n 5 []} truth 0))
  (define truth-classes (subvector{float | n (+ 1 classes-1) []} input 5))
  (define class-delta (*. class-scale (-. truth-classes class-pred)))
  (define class-cost (reduce{float | classes-1 [] []} +. (*. class-scale (expt (-. truth-classes class-pred) 2.0))))

  ;; acc is the stats accumulated, next is the box to compare next
  ;; returns new stats
  ;; acc = [best-idx best-iou best-rmse cur-idx]
  ;; should use tuples/records instead, cur-idx is being tracked as a float
  (define (box-cmp [acc [float 4]] [next [float 5]]) : [float 4]
     (define cur-idx (index{float | [4] [] 1} acc [3]))
     (define iou (yolo-box-iou next truth-box))
     (define rmse (yolo-box-rmse next truth-box))
     [rmse iou cur-idx 0.0])
     ;; (define best-idx (index{float | [4] [] 1} acc [0]))
     ;; (define best-iou (index{float | [4] [] 1} acc [1]))
     ;; (define best-rmse (index{float | [4] [] 1} acc [2]))
     ;; totally fake code
     ;; [0.0 0.0 0.0 0.0])
     ;; real code
     ;; (select{float |} (or (>. best-iou 0.0) (>. iou 0.0))
     ;;    (select{float |} (>. iou best-iou) [cur-idx iou rmse (+. 1.0 cur-idx)]
     ;;                                       [best-idx best-iou best-rmse (+. 1.0 cur-idx)])
     ;;    (select{float |} (<. rmse best-rmse) [cur-idx iou rmse (+. 1.0 cur-idx)]
     ;;                                         [best-idx best-iou best-rmse (+. 1.0 cur-idx)])))
  (define first-box : [float 5] (head{float | boxes-num-1 [5]} box-pred))
  (define first-box-state [0.0
                           (yolo-box-iou first-box truth-box)
                           (yolo-box-rmse first-box truth-box)
                           0.0])
  (define rest-boxes (tail{float | boxes-num-1 [5]} box-pred))
  (define best-box-stats (fold{float [float 4] | boxes-num-1 [5] } box-cmp first-box-state rest-boxes))
  best-box-stats)
  ;; (define best-box-idx (float->int (index{float | [4] [] 1} best-box-stats [0])))

  ;; (define (calc-box-delta [box [float 5]] [idx [int]])
  ;;    (select{float |} (= best-box-idx idx)
  ;;                     (best-yolo-box-delta box truth-box coord-scale obj-scale sqrt-flag rescore-flag)
  ;;                     (other-yolo-box-delta box noobj-scale)))
  ;; (define delta-boxes (calc-box-delta box-pred iota{| [(+ 1 boxes-num-1)]}))
  ;; (define dout (merge-box-and-class-delta{| (+ 1 classes-1) (+ 1 boxes-num-1)} delta-boxes class-delta))
  ;; dout)

;; ---------------------------- ACTIVATIONS ---------------------------------------------

; (define (leaky-relu [x [float]]) : float
;   (select{float |} (>. x 0.0) x (*. 0.1 x)))

; (define (leaky-relu-prime [x [float]]) : float
;   (select{float |} (>. x 0.0) 1.0 0.1))

; (define (linear [x [float]]) : float
;   x)

; (define (linear-prime [x [float]]) : float
;   1.0)

; (define (softmax{| in-1} [x [float (+ 1 in-1)]]) : [float (+ 1 in-1)]
;   (let [e (exp x)]
;     (/. e (reduce{float | in-1 [] []} +. e))))

; ; truth is one-hot encoding vector - there can only be 1 1.0 value, everything else is 0.0
; ; x is the output of softmax function
; (define (softmax-prime{| in} [x [float in]] [truth [float in]]) : [float in]
;   (-. x truth))

; turns softmax output vector to one-hot encoded vector -
; max value turns into 1, all others into 0
;;(define (softmax->class-vector{| in-1} [e [float (+ 1 in-1)]]): [float (+ 1 in-1)]
;;  (let ((max-val (reduce{float | in-1 [] []} max-float e)))
;;    ((fn ([v [float]] (select (=. v max-val) 1.0 0.0))) e)))


;; ---------------------------- FLATTEN (?) ---------------------------------------------
;; Flatten layers are to feed data into fully connected layers 
;; (since they require 1D input no matter what kind of data is pr;cessed)
; (define (flatten-2d-fwd{| @in out} [input [float @in]]) : [float out]
;   (reshape [out] input))

; (define (flatten-2d-bwd{| @in out} [dy [float out]]) : [float @in]
;   (reshape [@in] dy))



;; ---------------------------- MAIN ---------------------------------------------

;(flatten-2d-fwd{| [3 3 3 3] 81} (int->float iota{|[3 3 3 3]}))
; (subarray/2{int | 5 5 3 3} iota{| [5 5]} [0 0])
;; (define conv (conv-2d{| 2 1 2 1 0} (int->float iota{| [3 3]})
;;                      [[0.5 1.0] [1.5 2.0]]
;;                      1.0))

;; (define (batch-norm-2d{ | n-1 k}
;;                        [input [float k (+ 1 n-1) (+ 1 n-1)]]
;;                        [rolling-mean [float k]]
;;                        [rolling-var [float k]]
;;                        [bias [float k]]
;;                        [train [bool]])
;; (batch-norm-2d{| 1 1} (int->float iota{| [1 2 2]}) [0.0] [0.0] [1.3] #t)

;; (define (max-pool-2d{| n-1 pool-size-1 out} [data [float (+ 1 n-1) (+ n-1 1)]]) : [float out out]

;; (max-pool-2d{| 3 1 2} (int->float iota{| [4 4]}))
; (+. 1.0 (index{float | [5 5] [] 2} (int->float iota{| [5 5]}) (+ (replicate{int | [3 3] [3 3 2]} (indices-of/2{| 3 3}))
;                                     (replicate{int | [3 3] [2]} ((fn ([id [int]]) [(/ id 3) (% id 3)]) iota{| [3 3]})))))
;; (+. 1.0 (subarray/2{float | 5 5 3 3} (int->float iota{| [5 5]})
;;                                      ((fn ([id [int]]) [(/ id 3) (% id 3)]) iota{| [3 3]})))
;; (-. (int->float iota{| [1 2 2]}) (int->float iota{| [1 2 2]}))

;; Precondition: boxes-arr-size = 5 * boxes-num
;; Precondition: n = boxes-arr-size + classes-1 + 1
;; (define (detection-2d{| n boxes-arr-size boxes-num-1 classes-1}
;;                       [input        [float n]]
;;                       [truth        [float n]]
;;                       [sqrt-flag    [bool]]
;;                       [rescore-flag [bool]]
;;                       [obj-scale    [float]]
;;                       [noobj-scale  [float]]
;;                       [coord-scale  [float]]
;;                       [class-scale  [float]])
(detection-2d{| 20 10 1 9 } (int->float iota{| [20]}) (int->float iota{| [20]}) #t #f 1.3 0.9 1.1 0.7)
